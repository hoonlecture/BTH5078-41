# Fundamentals of computational data analysis using R

## A primer on programming using R: lesson 1

#### Contact: wisekh@skku.edu

---

### Index

- [Expressions](#expressions)
- [Numbers](#numbers)
- [Logicals](#logicals)
- [Characters](#characters)
- [Variables](#variables)
- [Vectors](#vectors)
- [Vector generation](#vector-generation)
- [Vector recycling](#vector-recycling)
- [Some vectorized numeric operations](#some-vectorized-numeric-operations)
- [Some vectorized logical operations](#some-vectorized-logical-operations)
- [Some vectorized character operations](#some-vectorized-character-operations)
- [Some general vector utilities](#some-general-vector-utilities)

### Check your understanding

- [Check 1](#check-your-understanding-1)
- [Check 2](#check-your-understanding-2)
- [Check 3](#check-your-understanding-3)

---

### Expressions

After starting R, an R terminal window will be launched. If you bring that window into focus, you can
  start entering commands at the `>` prompt. An 'expression' is another term for a command that the
  R interpreter can process and potentially return a computed value. Pressing `<ENTER>` after a complete 
  expression results in the execution of that expression. If the expression is clearly incomplete, 
  pressing `<ENTER>` will take you to the next line, where you can continue entering your expression.

```
4 + 3        ## a complete expression: the R program knows how to interpret this and return 7

4 +          ## an imcomplete expression
3            ## the next line is interpreted as a continuation; now can be interpreted/is complete

```

If the expression does not include an assignment of the resulting value to a variable (like the 
  example above), the resulting value is typically printed out on the screen. 

The simplest expressions are literal values themselves. Each value has a data type associated with it, which 
  can be determined using the `class()` function. The data type determines which operators and functions 
  can be applied to the value.

A literal value by itself is a complete expression. So you can enter any acceptable value at the `>` prompt,
  press `<ENTER>`, and the value will be displayed on subsequent lines in the terminal. 

```
## Here is an example comment

3.14159                 ## numeric literal value

4L                      ## integer literal

"quick brown fox"       ## character literal

TRUE                    ## logical literal

```

Comments in R are designated by the `#` symbol. That is, anything you type after a `#` symbol will
  be ignored by the R command parser. The `#` can appear anywhere on a line. That is, it does not need 
  to be in the first column, though that is allowed as well.

[Return to index](#index)

---

### Numbers

The first data types we will look at are types used to represent numbers. There are several data
  types that are used to represent numbers. The most common is the 'numeric' type, which is
  encoded in a double-precision floating point format. The numeric type is most useful for 
  representing fractional numbers, like 1.23 as well as very large or very small magnitude numbers, 
  like `1.3e36` (1.3 x 10<sup>36</sup>) or `3.97e-24` (3.97 x 10<sup>-24</sup>). Another data type
  used for representing numbers is 'integer'. Integers are used to represent whole
  numbers (positive, negative and zero), like the counting numbers. In R these are primarily used
  for counting (no surprise) and indexing positions of particular values in more complex data 
  structures. R also has good support for representing complex numbers (numbers composed of 'real' 
  and 'imaginary' parts), but we won't describe those further in this class. For most practical 
  purposes, integers and doubles can be used interchangeably, so we will gloss over the differences 
  and conversion rules for now. Note that both 32-bit and 64-bit versions of R both use double precision
  floating point and long-integer representations of numbers. The primary difference between these
  versions is the size of pointers, which has implications for the maximum size of data structures
  that can be generated by the two versions, but does not affect the representations of individual 
  numbers.

An integer value is composed solely of an optional sign and digits. It should be followed by 
  `L` (for 'long integer') to ensure R understands an integer is intended. A numeric value can be composed 
  of digits, an optional sign, an optional single decimal place, and either `E` or `e` followed by
  an positive or negative integer exponent (see above for some examples):

```
2                  ## a super-simple numeric literal value
2L                 ## the almost equally simple integer equivalent

```

A function is a bit of computer code that can be called by name, given an argument (in parentheses
  following the function's name), and returns a value and/or performs some operations. One simple 
  function is `class()`, which tells you the data type of its argument. To find out the details of
  what a function does, you can precede the function name (unquoted) with a `?`, or call the 
  `help()` function with the function name (unquoted) as argument:

```
class(2)                ## looks like an integer, but ...
class(2L)
?class
help(class)             ## 'help()' is a function; can pass a function as argument by passing name
 
```

An expression can be made by combining operators (like the `+` below) with values (like the numeric
  values `2` and `3` below). You can find out more about an operator by placing the operator in
  single or double quotes and preceding it with a `?`, or by calling the `help()` function:

```
2 + 3                   ## a complete expression with two literal values and one operator (`+`)
class(2 + 3)            ## the class of the result of the operation
2L + 3L                 ## integer math
class(2L + 3L)          ## result is integer too
2L + 3                  ## mixing integer and numeric: integer gets converted to numeric
class(2L + 3)
?"+"
help('+')
?"Syntax"               ## where to find operators and precedence
??precedence            ## in case you forget, ?? does a full-text search of help library
2 / 3                   ## divide
2 * 3                   ## multiply
2 - 3                   ## subtract
2 ^ 3                   ## power (coefficient and exponent need not be positive nor integer)

```

If you hate to memorize precedence tables (I do) or want to change the order of operations, you
  can enclose parts of the expression in parentheses (per the usual mathematical conventions)
  to ensure execution in the order you intend:

```
2 + 3 / 5
(2 + 3) / 5
3 ^ (1 / 2)
(3 ^ (1 / 2)) ^ 2

```

[Return to index](#index)

---

### Check your understanding 1:

1) what is the third-root of 5

2) what is the sum of 500,726 and 324,781, divided by 67?

3) what is 3.14 to the 3.14 power?

[Return to index](#index)

---

### Logicals

Certain operators (and functions) which take numbers as arguments, can return logical
  values (a data type that can only represent the two values 'TRUE' and 'FALSE'). The 
  equality operators are a good example:

```
2 < 3                   ## is 2 less than 3?
2 >= 3                  ## is 2 greater than or equal to 3?
2 == 3                  ## is 2 equal to 3?
2 == 2                  ## is 2 equal to 2?
2 != 3                  ## is 2 not equal to 3?
?"<"                    ## what does the '<' operator do?
class(2 < 3)            ## what data type is returned by the '<' operator?
1 : 10
3 %in% 1:10             ## is 3 in the set of integers spanning from 1 to 10 (inclusive)?
-3 %in% 1:10            ## is -3 in the set of integers spanning from 1 to 10 (inclusive)?

```

Logical values are represented by the unquoted (case-sensitive) literal values `TRUE`, `T`, 
  `FALSE`, and `F`:

```
TRUE                    ## ok
True                    ## oops: case sensitive
true                    ## oops: case sensitive
T                       ## ok
t                       ## oops: case sensitive + the name of the matrix transposition function
TR                      ## oops, only T or TRUE
class(T)
FALSE                   ## ok
FA                      ## oops, only F or FALSE
F                       ## ok

```

Logical values can be combined using the operators `&&` (and) as well as `||` (or).

They can also be combined with the function `xor()` (exclusive or), and negated with the
unary (only takes one argument) operator `!`:

```
TRUE && TRUE            ## what is (T and T)?TRUE && FALSE           ## what is (T and F)?TRUE || TRUE            ## what is (T or T)?  this is the one that differs from 'xor()'!!!TRUE || FALSE           ## what is (T or F)?FALSE || FALSE          ## what is (F or F)?xor(TRUE, FALSE)        ## what is (T xor F)?xor(TRUE, TRUE)         ## what is (T xor T)? this is the one that differs from '&&'!!!xor(FALSE, FALSE)       ## what is (F xor F)?!T                      ## not TRUE!F                      ## not FALSE
```

[Return to index](#index)

---

### Characters

Although R is primarily a programming language for crunching numbers, we still often need
  to represent 'strings' that is a series of characters, which can include not only digits,
  signs, and decimal places, but any letters, numbers, punctuation, label plots, etc. This 
  job is handled by the 'character' data type in R. Character values are used as labels for
  group membership (e.g. treated vs. untreated; allele status; gender; etc) when 
  analyzing categorical data. The 'character' type is also used to specify information
  such as file paths, software package information, usage hints, error messages, etc.
  Character literal values are set apart by being enclosed in single or double quotes. 
  In R, single and double quotes are equivalent. The norm is to use double quotes, unless 
  you need to embed a double quote in a string, in which case enclose the entire string
  in single quotes.

```
"abc de"                        ## 1x and 2x quotes equivalent; 2x 'preferred'class("abc de")                 ## whitespace characters count too!'"'                             ## use 2x to embed 1x and vice-versaclass('')                       ## an empty string in quotes is still of type characternchar('')                       ## how many characters long (\0 not counted)nchar('abc de')substr('abc de', 2, 4)          ## substring: 2d to 4th character, inclusivetolower('AbCdE123_')            ## convert to lower-casetoupper('AbCdE123_')            ## convert to upper-casesub('b', 'd', 'ab cba')         ## substitute first instance of 'b' w/ 'd'; regex-friendlygsub('b', 'd', 'ab cba')        ## substitute all instances of 'b' w/ 'd'; regex-friendly grepl('bc', 'abcba')            ## does second argument contain first as substring? regex-friendlygrepl('yx', 'abcba')            ## does second argument contain first as substring? regex-friendly'yx' %in% c('ab', 'yx', 'fg')'yx' %in% c('ab', 'yt', 'fg')
```

[Return to index](#index)

---

### Variables

Variables in R (and other programming languages) are reminiscent of the variables (e.g. `x` and `y`) 
  encountered in elementary algebra. In R, they are names used to refer to an object (a spot in computer
  memory) that holds one or more values which can be changed by the program. All the value types we 
  discussed can be assigned to a variable. The variable name is used to assign values to the underlying
  object or read values from the object. The `<-` operator is normally used for assignment. Although
  the `=` operator will often work, it will fail if used e.g. for assignment within a function call, 
  since it can be confused with parameter assignment. It is therefore best to use `->` for assignment
  to variables and `=` only for assignment to named parameters. 

Variable names can be composed only of letters, digits, periods, and underscores. They cannot contain 
  dashes, spaces, other punctuation, etc. Variable names must begin with a letter or a period (not 
  a number or an underscore). The `ls()` command is used to retrieve a list of the currently defined 
  variables. If you start a variable name with a period, the variable will be 'hidden' from the default 
  form of the `ls()` command. Variable names are distinguished from 'character' values because all
  character values are enclosed in quotes, while variable names are not.

In general, you should try to use descriptive variable names so that your code can be more easily 
  understood. However, for short self-contained pieces of code, quick prototyping, or where readability 
  is not otherwise impaired, it is common to see single letter variable names employed. When doing so, 
  it is important to remember that there are base functions called `c()`, `q()` and `t()`. Defining a 
  variable named `c` would result in the `c()` command being 'masked' for some purposes (such as 
  passing the function to another function, unless the full package path is specified (which usually 
  is not done). Therefore, it is a best to avoid using `c`, `q`, or `t` for user-defined variable names.

Numeric operators and functions work on variables:

```
x <- 3                    ## assign literal value `3` to variable named `x`; avoid c, q, t for variable namesxx <- 2 + 3                ## assign result of operation to `x`xx <- 2y <- 3x + yz <- x + y                ## variable names used in place of the values they storez.a <- 97                  ## 'hidden' variable namels()                      ## list all the defined variables (except those starting with '.')ls(all.names=T)           ## incantation discovered by reading the scrolls returned by '?ls'rm(x)                     ## get rid of the variable xls(all.names=T)rm(list=ls())             ## delete all defined variables (except those starting with '.').arm(list=ls(all.names=T))  ## really delete everything; could also 'rm(.a)' to just get rid of .a.a                        ## really is gonels(all.names=T)system.time(x <- 3)       ## how much time does it take to perform an assingment?system.time(x = 3)        ## oops! is 'x' a variable or a parameter to be passed to system.time()??system.time              ## for instance, `gcFirst` is a parameter name you could assign to
```

Character operators and functions also work with variables:

```
x <- 'abc'xgrepl('y', x)grepl('bc', x)x %in% c('abc', 'bcde', 'cdefg')
```

And logical operators/functions work with variables as well:

```
x <- Ty <- Fx && yx && xy && yx || yx || xy || yxor(x, y)xor(x, x)xor(y, y)
```

[Return to index](#index)

---

### Vectors

In R, the basic data type is vector-like (a series or linear array of values), which is 
  different from most other programming languages. It is best to think a 'scalar' (that is,
  a single value, or variable holding a single value) in R as simply being a vector of 
  length 1.

```
x <- 30       xclass(x)length(x)                    ## how many values are stored in the variable 'x'?x <- c(1, -10, 100)          ## concatenation function; store 3 successive values in 'x'xclass(x)length(x)x <- c(T, F, T)              ## works for logical types tooxclass(x)length(x)x <- c('abc', '', 'de')      ## and character typesxclass(x)length(x)
```

[Return to index](#index)

---

### Vector generation

Sometimes you need to generate a series of values following a fairly simple pattern. 
  There are several operators and functions available to help:

```
1 : 10                             ## from 1 to 10, by 1, inclusivex <- 5 : -5                        ## from 5 to -5, by 1 (or rather by -1), inclusivexclass(x)                           ## ':' produces integers!seq(from=1, to=10, by=2)           ## allows a different 'stride'x <- seq(from=10, to=1, by=-2.5)   ## stride need not be integer, but needs correct signxseq(from=1, to=10, length.out=19)  ## or just specify output vector length; let R figure stridex <- rep(5, 10)                    ## repeat the same value a specified number of timesxx <- rep('abc', 5)                 ## works for characterxx <- rep(c(T, F), 5)               ## works for logicalxx <- rep(1:3, 5)                   ## you can repeat a seriesxx <- rep(seq(from=-1, to=-2, by=-0.25), 3)x
```

[Return to index](#index)

---

### Check your understanding 2

1) Generate the series from 1 to 100 counting by 3.5

2) How many numbers did you generate in #1? Please don't manually count!!!

3) Generate the series from 10 to 1 counting by 2s

4) Generate a 25 element vector by repeating the series: 'a', 'b', 'c', 'd', 'e'

5) Generate a 25 element vector with unique sequential values evenly spaced between 0 and 1

[Return to index](#index)

---

### Vector recycling

Vectors of different lengths can be combined by operators or functions. This often results in the shorter 
  vector being 'recycled', that is, the shorter vector (say 'y') is concatenated to itself until it is at 
  least as long as the longer vector (say 'x'), then the tail is trimmed until it is the same length as x. 
  The resulting concatenated/trimmed vector is combined with 'x' as if both vectors always had the 
  same length. If the length of 'x' is not an integer multiple of the length of 'y', then a warning is 
  issued. However, if the length of 'x' is an integer multiple of the length of 'y', no warning is given. 
  Utilizing this 'feature' can lead to more confusion of code maintainers (like yourself a few months later) 
  that can outweigh any advantages. It is best to only combine vectors of equal length unless one of the vectors
  has a length of 1 (since the intent there is usually pretty clear).

```
x <- 1 : 10xx + 3                                  ## vector of length 1 (3) 'recycled'x * 3                                  ## vector of length 1 (3) 'recycled'x ^ 2                                  ## vector of length 1 (2) 'recycled'x <- 1 : 10y <- 21 : 30xyx + y                                  ## vectors of equal length: no recyclingx <- 1 : 4y <- 1 : 2xyx + y                                  ## longer length multiple of shorter: shorter recycles w/o warningx <- 1 : 4y <- 1 : 3xyx + y                                  ## longer not multiple of shorter: recycles shorter w/ warning
```

[Return to index](#index)

---

### Some vectorized numeric operations

```
x <- 1 : 10sum(x)                                                 ## sum up the whole series; yields single numberprod(x)                                                ## product of series; yields single numbercumsum(x)                                              ## cumulative sum; yields vector w/ length == length(x)mean(x)                                                ## average of the series; yields one numbersd(x)                                                  ## standard deviation (sample, not population)summary(x)                                             ## check it outquantile(x, probs=c(0, 0.1, 0.25, 0.5, 0.75, 0.9, 1))  ## you can set the probabilities to whateverx <- c(0.02345, 0.50000, 0.98765)round(x)round(x, digits=2)                                     ## decimal placessignif(x, digits=2)                                    ## digitsx <- 1 : 10x %in% 5 : 20                                          ## %in% makes more sense when working with vectors w/ length > 1
```

[Return to index](#index)

---

### Some vectorized logical operations

```
x <- 1 : 10x < 8                                                  ## yields logical vector of equal length to 'x'sum(x < 8)                                             ## when logical treated as numbers, T==1; F==0table(x < 8)                                           ## group counts (here, TRUE and FALSE are groups)x >= 5sum(x >= 5)                                            ## how many values in x are greater than or equal to 5?x < 8 && x >= 5   ## oops!                             ## '&&' not a vector operator!!! Only right if length(x) == 1.x < 8 & x >= 5                                         ## vectorized 'and'; yields logical of same length as 'x'x > 8 || x < 5    ## oops!                             ## '||' not a vector operator!!! Only right if length(x) == 1.x > 8 | x < 5                                          ## vectorized 'or'; yields logical of same length as 'x'sum(x > 8 | x < 5)                                     ## how many TRUE values resulted from vectorized 'or'?!(x > 8 | x < 5)                                       ## '!' vectorized: reverses all logical values
```

[Return to index](#index)

---

### Some vectorized character operations

```
x <- c('abcder', 'cdefghi', 'e', 'fgabc', 'ghijkla')nchar(x)                                               ## number of characters in each elementsubstr(x, 2, 4)                                        ## substrings: characters 2-4 from each elementsubstr(x, 2, 4) <- 'yz'                                ## can assign to substringsx                                                      ## see the changetoupper(x)xgsub('e', 'z', x)                                      ## substitute 'z' for 'e'xgrepl('e', x)                                          ## can I have an 'e' please?x %in% c("abc", "fyzbc",  "def", "cyzfghi")            ## %in% makes more sense when working with vectors w/ length > 1
```

[Return to index](#index)

---

### Some general vector utilities

Vectors can be combined using the `c()` function. 

```
x <- 1 : 10(x <- c(x, 11))                      ## add a value to end(x <- c(x, c(12, 13, 14)))           ## add three more values to endx <- 1:10y <- 21:30z <- c(x, y, x, -5:5, 10:1)          ## go nuts!z
```

A number of other commonly employed functions that work for vectors of any type:

```
x <- 1 : 10length(x)rev(x)                            ## reverse orderrev(x)[3](x <- c(1:5, 4:1, 1:3, 2:1))table(x)                          ## count distinct valuessort(x)         sort(table(x))unique(x)                         ## collapse redundant valuessort(unique(x))(x <- c('ab', 'a', 'ac', 'b', 'bd', 'b', 'ab', 'ab'))table(x)sort(x)sort(table(x), decreasing=T)      ## default order is increasingx <- 1 : 100i <- x > 35table(i)
```

Set operations do not track member order and collapse redundant members:

```
x <- c(1 : 10, 10 : 1)            ## vector has redundant membersy <- 6 : 15z <- 6 : 15xyzunion(x, y)                       ## put the 'sets' together, no redundancyintersect(x, y)                   ## what do the sets share?setdiff(x, y)                     ## what does x have that y does not?setdiff(y, x)                     ## what does y have that x does not?setequal(x, y)                    ## is the set memebership identical?setequal(z, y)  
```

[Return to index](#index)

---

### Check your understanding 3

1) What is the sum of the integers from 1 to 100 (inclusive)?

2) What results from summing the squares of the integers from 1 to 100 (inclusive)?

3) What is the mean of the even integers from 2 to 100 (inclusive)?

4) Make a vector containing the integers from -10 to -1 followed by the integers from 10 to 1.

5) Reverse the order of elements in the vector you made in (4)

6) How many positive integers, when squared, yield
   a value of more than 200 and less than 3000?

[Return to index](#index)

---

## FIN!
